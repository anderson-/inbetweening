import os
import re
import time
import copy
import numpy
import subprocess
import FreeCAD as App
import FreeCADGui as Gui


IGNORELIST = ['App::Origin', 'App::Line', 'App::Plane']
FILEPATH = os.path.dirname(__file__)
STATE = {
    'frame': 0,
    'render': False,
    'play': False,
    'animation': None,
    'selection': None,
    'documentobs': None,
    'doc': None,
}


def Doc():
    return App.ActiveDocument


def createObjState(obj):
    pos = str(obj.Placement.Matrix).split('Matrix')[1]
    pos = pos.translate({ord(c):'' for c in ' ()'})
    pos = [float(i) for i in pos.split(',')]
    assert len(pos) == 16, f'Failed parsing: {str(obj.Placement.Matrix)}'
    color = None
    material = None
    transparency = 0
    if obj.TypeId == 'App::Link':
        material = obj.ViewObject.OverrideMaterial
        color = list(obj.ViewObject.ShapeMaterial.DiffuseColor)[:3]
        transparency = obj.ViewObject.ShapeMaterial.Transparency
    return {
        'name': obj.Name,
        'pos': pos,
        'visible': obj.Visibility,
        'material': material,
        'color': color,
        'transparency': transparency,
    }


def newMaterial(color=None, transparency=None):
    m = App.Material(
        DiffuseColor=(tuple(color or (0.80, 0.80, 0.80))[:3]),
        AmbientColor=(0.20, 0.20, 0.20),
        SpecularColor=(0.00, 0.00, 0.00),
        EmissiveColor=(0.00, 0.00, 0.00),
        Shininess=(0.20),
        Transparency=(float(transparency or 0.00)),
    )
    return m


def interpolate(v1, v2, delta):
    return v1 + (v2 - v1)*delta


def interpolateMaterial(s1, s2, delta):
    r = interpolate(s1.DiffuseColor[0], s2.DiffuseColor[0], delta)
    g = interpolate(s1.DiffuseColor[1], s2.DiffuseColor[1], delta)
    b = interpolate(s1.DiffuseColor[2], s2.DiffuseColor[2], delta)
    t = interpolate(s1.Transparency, s2.Transparency, delta)
    return newMaterial((r, g, b), t)


def applyObjState(state):
    obj = Doc().getObject(state['name'])
    if not obj:
        return
    obj.Placement = state['pos'].copy()
    obj.Visibility = state['visible']
    if obj.TypeId == 'App::Link' and 'material' in state:
        if state['material']:
            obj.ViewObject.OverrideMaterial = True
            obj.ViewObject.ShapeMaterial = state['material']
        else:
            obj.ViewObject.OverrideMaterial = False
            obj.ViewObject.ShapeMaterial = newMaterial()


def animObjState(obj, s1, s2, delta):
    if not obj:
        return
    obj.Placement = s1['pos'].slerp(s2['pos'], delta)
    # if obj.Visibility != s2['visible']:
    #     obj.Visibility = s2['visible']
    m1 = s1.get('material')
    m2 = s2.get('material')
    if s1['visible'] == False and not m1:
        m1 = newMaterial(None, 1)
    if s2['visible'] == False and not m2:
        m2 = newMaterial(None, 1)
    if obj.TypeId == 'App::Link':
        if m1 or m2:
            obj.Visibility = True
            obj.ViewObject.OverrideMaterial = True
            obj.ViewObject.ShapeMaterial = interpolateMaterial(
                m1 or newMaterial(),
                m2 or newMaterial(),
                delta
            )
        elif obj.ViewObject.OverrideMaterial:
            obj.ViewObject.OverrideMaterial = False
            obj.ViewObject.ShapeMaterial = newMaterial()


def getState():
    objs = Doc().findObjects()
    state = {}

    for obj in objs:
        if hasattr(obj, 'Placement') and obj.TypeId not in IGNORELIST:
            if obj.TypeId not in ['App::Link', 'App::Part']:
                App.Console.PrintWarning(f'warning: found {obj.FullName} as {obj.TypeId}\n')
                continue
            state[obj.Name] = createObjState(obj)

    App.Console.PrintMessage(f'state: {state}\n')
    return state


def newProp(obj, name, type_, value, subsection="", tooltip=""):
    if name in obj.PropertiesList:
        return
    obj.addProperty(f'App::Property{type_}', name, subsection, tooltip)
    setattr(obj, name, value)


class VideoRenderer:

    def __init__(self, ffmpeg):
        self.ffmpeg = ffmpeg
        self.pipein, self.pipeout = (None, None)
        self.tmpfile = '/tmp/stream.png'

    def begin(self, name, w=300, h=300, bg='Current', framerate=24, more=''):
        self.filename = name
        self.w = w
        self.h = h
        self.bg = bg
        self.count = 0

        self.pipein, self.pipeout = os.pipe()
        pid = os.getpid()
        if os.path.exists(self.tmpfile):
            os.remove(self.tmpfile)
        os.symlink(f'/proc/{pid}/fd/{self.pipein}', self.tmpfile)

        params = f'{self.ffmpeg} -y -f image2pipe -framerate {framerate} -i '
        params += f'/proc/{pid}/fd/{self.pipeout} -vcodec png '
        params += more
        params += self.filename

        self.p = subprocess.Popen(params.split(), stdin=None)

    def addFrame(self):
        view = Gui.activeDocument().activeView()
        view.saveImage(self.tmpfile, self.w, self.h, self.bg)
        self.count += 1
        if self.count % 10 == 0:
            App.Console.PrintMessage(f'Wrote {self.count} frames\n')
            Gui.updateGui()

    def end(self):
        os.close(self.pipein)
        os.close(self.pipeout)
        self.p.wait()
        os.remove(self.tmpfile)
        App.Console.PrintMessage(f'Done wrote {self.count} frames\n')


class Animation:

    @staticmethod
    def getObject():
        return Doc().getObject('Animation')

    @staticmethod
    def getInstance():
        return Animation(Animation.getObject())

    def __init__(self, obj=None):
        if not obj:
            obj = Doc().addObject('App::DocumentObjectGroupPython', 'Animation')
        self.obj = obj
        self.steps = {}
        for step in obj.Group:
            self.steps[step.Name] = Step(step, obj)
        if not obj.Group:
            self.addStep()
        obj.Proxy = self
        obj.ViewObject.Proxy = self
        # Properties
        newProp(obj, 'OutputFilename', 'File', 'video.mp4', 'Video')
        newProp(obj, 'FFmpeg', 'File', '', 'Video')
        newProp(obj, 'Width', 'Integer', 1080, 'Video')
        newProp(obj, 'Height', 'Integer', 720, 'Video')
        newProp(obj, 'Background', 'Enumeration', [
            'Current', 'Black', 'White', 'Transparent'
        ], 'Video')
        newProp(obj, 'FPS', 'Integer', 24, 'Video')

    def onChanged(self, fp, prop):
        App.Console.PrintMessage(f'onChanged {prop}\n')
        pass

    def execute(self, fp):
        App.Console.PrintMessage(f'execute {fp}\n')

    def getIcon(self):
        return f'{FILEPATH}/icons_i10g/animation.svg'

    def addStep(self, before=None):
        if not before:
            id = 'Step{:0>3d}'.format(len(self.obj.Group))
            obj = Doc().addObject('App::DocumentObjectGroupPython', f'Step')
            App.Console.PrintError(f'---{id}\n')
            obj.Label = id
            step = Step(obj, self.obj)
            self.steps[obj.Name] = step
            self.obj.addObject(obj)
            App.Console.PrintError(f'addStep\n')
            STATE['frame'] = len(self.obj.Group) - 1
        else:
            App.Console.PrintError(f'addStep{before}\n')
            tmp = Doc().addObject('App::DocumentObjectGroupPython', 'TMPGroup')
            for i in range(len(self.obj.Group) - before):
                App.Console.PrintError(f'remove{before}\n')
                obj = self.obj.removeObject(self.obj.Group[before])[0]
                obj.Label = f'_{obj.Label}'
                tmp.addObject(obj)
            self.addStep()
            id0 = len(self.obj.Group)
            for i in range(len(tmp.Group)):
                App.Console.PrintError(f'add0\n')
                obj = tmp.removeObject(tmp.Group[0])[0]
                obj.Label = 'Step{:0>3d}'.format(id0 + i)
                self.obj.addObject(obj)
            Doc().removeObject(tmp.Name)

    def play(self):
        prev = None
        Gui.Selection.clearSelection()
        Gui.runCommand('Std_DrawStyle', 5)
        STATE['play'] = True
        for i, obj in enumerate(self.obj.Group):
            STATE['frame'] = i
            step = self.steps[obj.Name]
            if prev is None:
                prev = step
                continue
            prev.obj.ViewObject.signalChangeIcon()
            step.obj.ViewObject.signalChangeIcon()
            for delta in numpy.append(numpy.arange(0, 1, 1/(prev.frames-1)), 1):
                step.anim(prev, delta)
                Gui.updateGui()
                time.sleep(0.01)
                if not STATE['play']:
                    break
            prev = step
            if not STATE['play']:
                break
        STATE['play'] = False
        Gui.runCommand('Std_DrawStyle', 6)
        Doc().recompute(None, True, True)

    def video(self):
        name = self.obj.getPropertyByName('OutputFilename')
        w = self.obj.getPropertyByName('Width')
        h = self.obj.getPropertyByName('Height')
        bg = self.obj.getPropertyByName('Background')
        fps = self.obj.getPropertyByName('FPS')
        ffmpeg = self.obj.getPropertyByName('FFmpeg')
        if not ffmpeg:
            App.Console.PrintError(f'FFmpeg path not set!\n')
            return
        vr = VideoRenderer(ffmpeg)
        vr.begin(name, w, h, bg, fps)
        prev = None
        STATE['render'] = True
        STATE['play'] = True
        Gui.Selection.clearSelection()
        Gui.runCommand('Std_DrawStyle', 5)
        for i, obj in enumerate(self.obj.Group):
            STATE['frame'] = i
            step = self.steps[obj.Name]
            App.Console.PrintError(f'step {step.name}\n')
            if prev is None:
                prev = step
                continue
            prev.obj.ViewObject.signalChangeIcon()
            step.obj.ViewObject.signalChangeIcon()
            for delta in numpy.append(numpy.arange(0, 1, 1/(prev.frames-1)), 1):
                step.anim(prev, delta)
                Gui.updateGui()
                vr.addFrame()
                if not STATE['play']:
                    break
            prev = step
            if not STATE['play']:
                break
        Gui.runCommand('Std_DrawStyle', 6)
        vr.end()
        STATE['play'] = False
        STATE['render'] = False
        Doc().recompute(None, True, True)

    def __getstate__(self):
        return None

    def __setstate__(self,state):
        return None


class Step:
    def __init__(self, obj, animation):
        obj.Proxy = self
        obj.ViewObject.Proxy = self
        self.obj = obj
        self.name = self.obj.Name
        self.updateState()
        self.animation = animation
        obj.ViewObject.signalChangeIcon()

    def onChanged(self, fp, prop):
        App.Console.PrintMessage(f'onChanged\n')
        if prop == 'Frames':
            self.frames = self.obj.getPropertyByName('Frames')

    def execute(self, fp):
        App.Console.PrintMessage(f'execute\n')

    def getIcon(self):
        if STATE['frame'] == self.animation.Group.index(self.obj):
            App.Console.PrintMessage(f'getIcon2 {id} {self.obj.Label}\n')
            return f'{FILEPATH}/icons_i10g/selected_step.svg'
        App.Console.PrintMessage(f'getIcon {id} {self.obj.Label}\n')
        return f'{FILEPATH}/icons_i10g/step.svg'

    def updateState(self, force=False):
        if force:
            self.obj.removeProperty('DocState')
        # Properties
        newProp(self.obj, 'Frames', 'Integer', 30, 'Animation')
        newProp(self.obj, 'DocState', 'PythonObject', getState())
        self.state = copy.deepcopy(self.obj.getPropertyByName('DocState'))
        self.frames = self.obj.getPropertyByName('Frames')

        App.Console.PrintMessage(f'load state: {self.state}\n')
        for value in self.state.values():
            value['pos'] = App.Placement(App.Matrix(*value['pos']))
            if value['material']:
                value['material'] = newMaterial(
                    value['color'],
                    value['transparency']
                )
            value['obj'] = Doc().getObject(value['name'])
        App.Console.PrintMessage(f'after state: {self.state}\n')

    def apply(self):
        for objState in self.state.values():
            applyObjState(objState)
        Doc().recompute(None, True, True)

    def anim(self, prev, delta):
        for name, objState in self.state.items():
            animObjState(objState['obj'], prev.state[name], objState, delta)

    def __getstate__(self):
        return None

    def __setstate__(self,state):
        return None


class DocObs():
    def __init__(self):
        App.addDocumentObserver(self)

    def slotActivateDocument(self, doc):
        App.Console.PrintMessage(f'slotActivateDocument frame {doc}\n')
        if doc != STATE['doc']:
            STATE['doc'] = doc
            if doc.getObject('Animation'):
                STATE['animation'] = App.Animation.getInstance()
                App.Console.PrintMessage(f'newAnimation\n')
            else:
                STATE['animation'] = None
                App.Console.PrintMessage(f'removeAnimation\n')

    def slotDeletedDocument(self, doc):
        if STATE['doc'] == doc:
            STATE['doc'] = None
            STATE['animation'] = None



class StepSelectionCallback:
    def __init__(self):
        Gui.Selection.addObserver(self)

    def addSelection(self, doc, obj, sub, pos):
        App.Console.PrintMessage(f'addSelection frame {doc}\n')
        a = STATE['animation']
        if obj in a.steps:
            oldSelectedObj = a.obj.Group[STATE['frame']]
            selectedObj = a.steps[obj].obj
            STATE['frame'] = a.obj.Group.index(selectedObj)
            oldSelectedObj.ViewObject.signalChangeIcon()
            selectedObj.ViewObject.signalChangeIcon()
            STATE['fcount'] = len(a.obj.Group)
            App.Console.PrintMessage(f'Selected frame {STATE["frame"]}\n')
            a.steps[obj].apply()


class Inbetweening(Gui.Workbench):
    MenuText = 'Inbetweening'
    ToolTip = 'Simple Animation Workbench'
    Icon = f'{FILEPATH}/icons_i10g/i10g.svg'

    def GetClassName(self):
        return 'Gui::PythonWorkbench'

    def Initialize(self):
        App.Console.PrintMessage(f'Initialize workbench {id(self)}\n')
        self.appendToolbar(f'TestTools{id(self)}', [
            'ReloadMacro', 'CreateAnimation', 'CreateExampleCmd',
        ])
        self.appendToolbar(f'Control{id(self)}', [
            'FirstFrameCmd', 'PrevFrameCmd', 'PlayCtrlCmd',
            'PauseCtrlCmd', 'NextFrameCmd', 'LastFrameCmd',
        ])
        self.appendToolbar(f'Tools{id(self)}', [
            'AddFrameCmd', 'CopyFrameCmd', 'UpdateFrameCmd',
        ])
        self.appendToolbar(f'Render{id(self)}', [
            'RenderCmd', 'StopRenderCmd',
        ])

    def Activated(self):
        App.Console.PrintMessage(f'Activated\n')
        pass

    def Deactivated(self):
        pass

    def ContextMenu(self, recipient):
        App.Console.PrintMessage(f'ContextMenu\n')


class ReloadMacro():
    def GetResources(self):
        return {'Pixmap': f'{FILEPATH}/icons_i10g/reload.svg',
                'MenuText': 'Reload Macro',
                'ToolTip': 'Reload Macro'}

    def Activated(self):
        App.Console.PrintMessage(f'Reloading macro. Command {id(self)}\n')
        try:
            Gui.Selection.removeObserver(STATE['selection'])
            App.removeDocumentObserver(STATE['documentobs'])
        except:
            pass
        Gui.activateWorkbench('StartWorkbench')
        Gui.removeWorkbench('Inbetweening')
        Gui.runCommand('Std_RecentMacros', 0)
        Gui.activateWorkbench('Inbetweening')

    def IsActive(self):
        return True


class CreateAnimation():
    def GetResources(self):
        return {'Pixmap': f'{FILEPATH}/icons_i10g/i10g.svg',
                'MenuText': 'Create animation',
                'ToolTip': 'Create animation'}

    def Activated(self):
        App.Console.PrintMessage(f'CreateAnimation\n')
        STATE['animation'] = App.Animation.getInstance()

    def IsActive(self):
        App.Console.PrintMessage(f'Reloading macro. Command {STATE["animation"]}\n')
        App.Console.PrintMessage(f'Reloading macro. Command {App.ActiveDocument}\n')
        App.Console.PrintMessage(f'Reloading macro. Command {App.ActiveDocument == STATE["doc"]}\n')

        return (not STATE['animation']) and App.ActiveDocument and \
            App.ActiveDocument == STATE['doc']


class FirstFrameCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/first_frame.svg',
            'MenuText': 'Jump to first step',
            'ToolTip': 'Jump to first step',
        }

    def Activated(self):
        a = STATE['animation']
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(a.obj.Group[0])

    def IsActive(self):
        return STATE['animation'] and STATE['frame'] != 0 and not STATE['play']


class PrevFrameCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/prev_frame.svg',
            'MenuText': 'Previous step',
            'ToolTip': 'Previous step',
        }

    def Activated(self):
        a = STATE['animation']
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(a.obj.Group[STATE['frame'] - 1])

    def IsActive(self):
        return STATE['animation'] and STATE['frame'] != 0 and not STATE['play']


class PlayCtrlCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/play.svg',
            'MenuText': 'Play animation',
            'ToolTip': 'Play animation',
        }

    def Activated(self):
        STATE['animation'].play()

    def IsActive(self):
        return STATE['animation'] and not STATE['play']


class PauseCtrlCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/pause.svg',
            'MenuText': 'Pause animation',
            'ToolTip': 'Pause animation',
        }

    def Activated(self):
        STATE['play'] = False

    def IsActive(self):
        return STATE['animation'] and STATE['play'] and not STATE['render']


class NextFrameCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/next_frame.svg',
            'MenuText': 'Next step',
            'ToolTip': 'Next step',
        }

    def Activated(self):
        a = STATE['animation']
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(a.obj.Group[STATE['frame'] + 1])

    def IsActive(self):
        return STATE['animation'] and STATE['frame'] < STATE['fcount'] - 1 and \
            not STATE['play']


class LastFrameCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/last_frame.svg',
            'MenuText': 'Jump to last step',
            'ToolTip': 'Jump to last step',
        }

    def Activated(self):
        a = STATE['animation']
        Gui.Selection.clearSelection()
        Gui.Selection.addSelection(a.obj.Group[STATE['fcount'] - 1])

    def IsActive(self):
        return STATE['animation'] and STATE['frame'] < STATE['fcount'] - 1 and \
            not STATE['play']


class AddFrameCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/add.svg',
            'MenuText': 'Add Step',
            'ToolTip': 'Add Step',
        }

    def Activated(self):
        a = STATE['animation']
        a.addStep()

    def IsActive(self):
        return STATE['animation'] and not STATE['play']

class CopyFrameCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/copy.svg',
            'MenuText': 'Copy Step',
            'ToolTip': 'Copy Step',
        }

    def Activated(self):
        a = STATE['animation']
        selection = Gui.Selection.getCompleteSelection()
        if selection[0] == STATE['animation'].obj.Group[-1]:
            a.addStep()
        else:
            a.addStep(before=STATE['frame'] + 1)

    def IsActive(self):
        selection = Gui.Selection.getCompleteSelection()
        return STATE['animation'] and len(selection) == 1 and \
            selection[0] in STATE['animation'].obj.Group and not STATE['play']


class UpdateFrameCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/update.svg',
            'MenuText': 'Update Step',
            'ToolTip': 'Update Step',
        }

    def Activated(self):
        a = STATE['animation']
        obj = a.obj.Group[STATE['frame']]
        a.steps[obj.Name].updateState(True)

    def IsActive(self):
        return STATE['animation'] and not STATE['play']


class RenderCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/render.svg',
            'MenuText': 'Render Animation',
            'ToolTip': 'Export video file',
        }

    def Activated(self):
        STATE['animation'].video()

    def IsActive(self):
        return STATE['animation'] and not STATE['play'] and \
            STATE['animation'].getPropertyByName('FFmpeg') != ''


class StopRenderCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/abort.svg',
            'MenuText': 'Abort Render',
            'ToolTip': 'Cancel Export',
        }

    def Activated(self):
        STATE['play'] = False

    def IsActive(self):
        return STATE['animation'] and STATE['play'] and STATE['render']

class CreateExampleCmd():
    def GetResources(self):
        return {
            'Pixmap': f'{FILEPATH}/icons_i10g/animation.svg',
            'MenuText': 'Open Example',
            'ToolTip': 'Open Example',
        }

    def Activated(self):
        App.Console.PrintMessage(f'new\n')
        doc = App.newDocument('AnimationExample')
        App.Console.PrintMessage(f'setActive\n')
        App.setActiveDocument(doc.Name)
        App.Console.PrintMessage(f'create\n')
        Gui.runCommand('CreateAnimation')
        App.Console.PrintMessage(f'next\n')

        # create part
        p0 = doc.addObject('App::Part', 'Part')
        box = doc.addObject('Part::Box', 'Box')
        p0.addObject(box)
        p0.Visibility = False

        # create links
        l0 = doc.addObject('App::Link', 'Link')
        l0.setLink(p0)
        l1 = doc.addObject('App::Link', 'Link')
        l1.setLink(p0)
        l2 = doc.addObject('App::Link', 'Link')
        l2.setLink(p0)

        # set step 0
        l1.Placement.Base.x = 10
        l2.Placement.Base.x = 20
        doc.recompute()
        Gui.ActiveDocument.ActiveView.viewTrimetric()
        Gui.SendMsgToActiveView('ViewFit')

        Gui.runCommand('UpdateFrameCmd')

        # set step 1
        l0.Placement.Base.z = 10
        l0.Visibility = False

        l1.Placement.Base.z = 10
        l1.ViewObject.OverrideMaterial = True
        l1.ViewObject.ShapeMaterial = App.Material(DiffuseColor=(1, 0, 0))

        l2.Placement.Base.z = 10
        l2.Placement.Rotation.Angle = -numpy.pi/2
        # l2.Placement.Base.x += 20

        doc.recompute()
        Gui.SendMsgToActiveView('ViewFit')

        Gui.runCommand('AddFrameCmd')
        Gui.runCommand('FirstFrameCmd')

    def IsActive(self):
        return not STATE['play']


def init():
    # Commands
    Gui.addCommand('ReloadMacro', ReloadMacro())
    cmds = [
        CreateAnimation,
        FirstFrameCmd,
        PrevFrameCmd,
        PlayCtrlCmd,
        PauseCtrlCmd,
        NextFrameCmd,
        LastFrameCmd,
        AddFrameCmd,
        CopyFrameCmd,
        UpdateFrameCmd,
        RenderCmd,
        StopRenderCmd,
        CreateExampleCmd,
    ]
    for cmd in cmds:
        Gui.addCommand(cmd.__name__, cmd())

    # Workbench
    try:
        Gui.activateWorkbench('Inbetweening')
        Gui.removeWorkbench('Inbetweening')
    except:
        pass
    Gui.addWorkbench(Inbetweening())
    Gui.activateWorkbench('Inbetweening')
    if App.ActiveDocument:
        App.setActiveDocument(App.ActiveDocument.Name)


if __name__ == '__main__':
    App.Animation = Animation
    STATE['documentobs'] = DocObs()
    STATE['selection'] = StepSelectionCallback()
    init()
